<!DOCTYPE html>

<html>
<head>
  <title>studio_rental.rb</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="../docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>studio_rental.rb</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <p>Anthony decribed a part of its subscription system that does the pricing
for its self-service music studio business. They have a set of constraints
that must be satisfied in order to get, or not, a prefered pricing.</p>
<p>Constraints are:</p>
<ol>
<li>on the hours (ie: from 10am to 8pm),</li>
<li>on the days (ie: <code>mon</code>, <code>tue</code>, …, <code>sat</code>, and/or <code>sun</code>),</li>
<li>on the frequency (ie: up to 4 hours per week)</li>
<li>on the spreading (ie: can, or cannot, split its quota of hours), and</li>
<li>on the location (ie: only certain studio).</li>
</ol>

            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <p>A <code>Plan</code> holds the constraints details but before going there, we need to
represent the various values being part of the constraints.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
DAYS = %i[sun mon tue wed thu fri sat]

DAY_HOURS = (<span class="hljs-number">0</span>..<span class="hljs-number">23</span>).to_a

SPREADINGS = %i[consecutive split]

PERIODICITIES = %i[daily weekly monthly]

Frequency = Struct.new(<span class="hljs-symbol">:amount_of_hours</span>, <span class="hljs-symbol">:periodicity</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>The constraint on the location imply constraints on the studio. A <code>Studio</code> has
an unique identifier, a type, and a place. Each attribute will be a <code>String</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Studio = Struct.new(<span class="hljs-symbol">:id</span>, <span class="hljs-symbol">:type</span>, <span class="hljs-symbol">:place</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>This helps defining the scope required for the location constraint.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
SCOPES = %i[id type place]

Location = Struct.new(<span class="hljs-symbol">:scope</span>, <span class="hljs-symbol">:reference</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>With those values, we can envision a <code>Plan</code> class, holding the logic telling
if a prefered pricing must apply.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Plan = Struct.new(<span class="hljs-symbol">:days</span>, <span class="hljs-symbol">:hours</span>, <span class="hljs-symbol">:frequency</span>, <span class="hljs-symbol">:spreading</span>, <span class="hljs-symbol">:scope</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>Instanciating a <code>Plan</code> could look like this:</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Plan.new(
  <span class="hljs-symbol">days:</span> %i[sun sat],                              <span class="hljs-comment"># Week-ends only</span>
  <span class="hljs-symbol">hours:</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>], <span class="hljs-comment"># Evenings only</span>
  <span class="hljs-symbol">frequency:</span> Frequency.new(                       <span class="hljs-comment"># 4-hours per week</span>
    <span class="hljs-symbol">amount_of_hours:</span> <span class="hljs-number">4</span>,
    <span class="hljs-symbol">periodicity:</span> <span class="hljs-symbol">:weekly</span>,
  ),
  <span class="hljs-symbol">spreading:</span> <span class="hljs-symbol">:split</span>,                              <span class="hljs-comment"># Hours can be split</span>
  <span class="hljs-symbol">scope:</span> [                                        <span class="hljs-comment"># Small studios (&lt; 20 m²)</span>
    Location.new(
      <span class="hljs-symbol">scope:</span> <span class="hljs-symbol">:type</span>,
      <span class="hljs-symbol">reference:</span> <span class="hljs-string">"small"</span>,
    ),
  ],
)</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>After that, an algorithm could tell if the plan can be used for a
<code>Reservation</code>. A reservation can be summarized by a studio for period of time.
To tell if a candidate plan could apply, the <code>Resevation#can_use_plan?</code> method
will also need, a reservation <code>history</code> and a candidate <code>plan</code> to test
against.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Period = Struct.new(<span class="hljs-symbol">:start_at</span>, <span class="hljs-symbol">:end_at</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>)

Reservation = Struct.new(<span class="hljs-symbol">:studio</span>, <span class="hljs-symbol">:period</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_use_plan?</span><span class="hljs-params">(<span class="hljs-symbol">plan:</span>, <span class="hljs-symbol">history:</span>)</span></span>
    <span class="hljs-literal">false</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <p>Now to implement <code>#can_use_plan?</code> we need to ensure all constraints are
satisfied.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reservation</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_use_plan?</span><span class="hljs-params">(<span class="hljs-symbol">plan:</span>, <span class="hljs-symbol">history:</span>)</span></span>
    <span class="hljs-keyword">if</span> !days.<span class="hljs-keyword">include</span>?(period.start_day)
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Must be in the allowed days</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">if</span> !period.covered_hours.all? { <span class="hljs-params">|hour|</span> hours.<span class="hljs-keyword">include</span>?(hour) }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Must be in the allowed hours</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">if</span> !scope.all? { <span class="hljs-params">|location|</span> studio.match?(location) }
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Must be in the allowed scope</span>
    <span class="hljs-keyword">end</span>

    recent_period = frequency.period_before(period.start_at)
    recent_hours = history
      .select { <span class="hljs-params">|reservation|</span> reservation.overlap?(relevent_period) }
      .sum(<span class="hljs-number">0</span>) { <span class="hljs-params">|reservation|</span> reservation.duration_in_hours }

    <span class="hljs-keyword">if</span> spreading == <span class="hljs-symbol">:consecutive</span> &amp;&amp; recent_hours.positive?
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Must be consecutive hours over the plan's frequency</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-keyword">if</span> (period.duration_in_hours + recent_hours) &gt; frequency.amount_of_hours
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span> <span class="hljs-comment"># Must stay below the amount of hours of the plan</span>
    <span class="hljs-keyword">end</span>

    <span class="hljs-literal">true</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              <p>As much work as possible has been offloaded to all collaborators. I’m making
those rules and assumptions as I go. For instance, I don’t handle time zones,
I expect that the studio would be booked only for full hours, I went for
sliding windows for the frequency limits, and so on.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Studio</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">match?</span><span class="hljs-params">(location)</span></span>
    <span class="hljs-keyword">self</span>[location.scope] == location.reference
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reservation</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">duration_in_hours</span></span>
    delta_seconds = period.end_at.to_i - period.start_at.to_i
    (delta_seconds / <span class="hljs-number">3600.0</span>).ceil
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">overlap?</span><span class="hljs-params">(other_period)</span></span>
    period.overlap(other_period)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Frequency</span></span>
  WINDOWS = {
    <span class="hljs-symbol">daily:</span>        <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>,  <span class="hljs-comment"># 24 hours</span>
    <span class="hljs-symbol">weekly:</span>   <span class="hljs-number">7</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>,  <span class="hljs-comment">#  7 days</span>
    <span class="hljs-symbol">monthly:</span> <span class="hljs-number">30</span> * <span class="hljs-number">24</span> * <span class="hljs-number">60</span> * <span class="hljs-number">60</span>,  <span class="hljs-comment"># 30 days</span>
  }

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">period_before</span><span class="hljs-params">(time)</span></span>
    delta = WINDOWS.fetch(periodicity)
    Period.new(
      <span class="hljs-symbol">start_at:</span> Time.at(time.to_i - delta).utc,
      <span class="hljs-symbol">end_at:</span> time,
    )
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Period</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">start_day</span></span>
    index = start_at.wday
    DAYS[index]
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">covered_hours</span></span>
    start_ts = start_at.to_i
    end_ts = end_at.to_i
    hour_step = <span class="hljs-number">3600</span>
    start_ts.step(end_ts, hour_step).map { <span class="hljs-params">|ts|</span> Time.at(ts).utc.hour }
  <span class="hljs-keyword">end</span>

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">overlap?</span><span class="hljs-params">(other)</span></span>
    other.end_at &gt; start_at &amp;&amp; other.start_at &lt; end_at
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <hr>

            </div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>Imagine we’re starting from an existing from this specification. But, later
on, we wish to add another constraint. We will have the choice to make <code>Plan</code>
to take one more field and to not use that field for older plans. That may be
what already happened with <code>scope</code>. If <code>scope</code> is empty, then the constraint
doesn’t apply.</p>
<p>Instead of considering all our constraints at once. We can organize them in a
more structured way. That will have the advantage of splitting the
<code>#can_use_plan?</code> method and be easily extensible in the future.</p>

            </div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>A plan becomes a set of constraints.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
Plan = Struct.new(<span class="hljs-symbol">:constraints</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>)</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>And, the <code>can_use_plan?</code> reflects that.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
<span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Reservation</span></span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">can_use_plan?</span><span class="hljs-params">(<span class="hljs-symbol">plan:</span>, <span class="hljs-symbol">history:</span>)</span></span>
    context = { <span class="hljs-symbol">reservation:</span> <span class="hljs-keyword">self</span>, <span class="hljs-symbol">history:</span> history }
    plan.constraints.all? <span class="hljs-keyword">do</span> <span class="hljs-params">|constraint|</span>
      constraint.satisfied?(<span class="hljs-symbol">context:</span> context)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>The missing piece are obviously the constraints part. From the implementation
of <code>#can_use_plan?</code>, we can guess that the <code>Plan#constraints</code> holds a list of
objects responding to <code>#satisfied?</code>.</p>

            </div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>Initializing the plan is now a bit different. The rule has been promoted as an
explicit concept here, it isn’t an internal of the <code>#can_use_plan?</code> anymore.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
frequency = Frequency.new(
  <span class="hljs-symbol">amount_of_hours:</span> <span class="hljs-number">4</span>,
  <span class="hljs-symbol">periodicity:</span> <span class="hljs-symbol">:weekly</span>,
)

Plan.new(<span class="hljs-symbol">constraints:</span> [
  FrequencyRule.new(
    <span class="hljs-symbol">frequency:</span> frequency,
  ),
  DayOfWeekRule.new(
    <span class="hljs-symbol">allowed_days:</span> %i[sun sat],
  ),
  HourOfDayRule.new(
    <span class="hljs-symbol">allowed_hours:</span> [<span class="hljs-number">0</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">18</span>, <span class="hljs-number">19</span>, <span class="hljs-number">20</span>, <span class="hljs-number">21</span>, <span class="hljs-number">22</span>, <span class="hljs-number">23</span>],
  ),
  ConsecutiveSpreadingRule.new(
    <span class="hljs-symbol">frequency:</span> frequency,
  ),
  LocationRule.new(
    <span class="hljs-symbol">scope:</span> <span class="hljs-symbol">:type</span>,
    <span class="hljs-symbol">reference:</span> <span class="hljs-string">"small"</span>,
  ),
])</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>And the next bit would be to write those rules. Having one class per rule
gives a new space to put the logic that would only be related to a rule in
particular.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>
DayOfWeekRule = Struct.new(<span class="hljs-symbol">:allowed_days</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">satisfied?</span><span class="hljs-params">(<span class="hljs-symbol">context:</span>)</span></span>
    reservation_period = context.fetch(<span class="hljs-symbol">:reservation</span>).period
    allowed_days.<span class="hljs-keyword">include</span>?(reservation_period.start_day)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

HourOfDayRule = Struct.new(<span class="hljs-symbol">:allowed_hours</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">satisfied?</span><span class="hljs-params">(<span class="hljs-symbol">context:</span>)</span></span>
    reservation_period = context.fetch(<span class="hljs-symbol">:reservation</span>).period
    covered_hours(reservation_period).all? <span class="hljs-keyword">do</span> <span class="hljs-params">|hour|</span>
      allowed_hours.<span class="hljs-keyword">include</span>?(hour)
    <span class="hljs-keyword">end</span>
  <span class="hljs-keyword">end</span>

  private

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">covered_hours</span><span class="hljs-params">(period)</span></span>
    start_ts = period.start_at.to_i
    end_ts = period.end_at.to_i
    hour_step = <span class="hljs-number">3600</span>
    start_ts.step(end_ts, hour_step).map { <span class="hljs-params">|ts|</span> Time.at(ts).utc.hour }
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

LocationRule = Struct.new(<span class="hljs-symbol">:scope</span>, <span class="hljs-symbol">:reference</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">satisfied?</span><span class="hljs-params">(<span class="hljs-symbol">context:</span>)</span></span>
    reservation_studio = context.fetch(<span class="hljs-symbol">:reservation</span>).studio
    reservation_studio[scope] == reference
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

FrequencyRule = Struct.new(<span class="hljs-symbol">:frequency</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">satisfied?</span><span class="hljs-params">(<span class="hljs-symbol">context:</span>)</span></span>
    history = context.fetch(<span class="hljs-symbol">:history</span>)
    period = context.fetch(<span class="hljs-symbol">:reservation</span>).period
    recent_hours = recent_hours(<span class="hljs-symbol">prior_to:</span> period, <span class="hljs-symbol">history:</span> history)
    (recent_hours + period.duration_in_hours) &lt;= frequency.amount_of_hours
  <span class="hljs-keyword">end</span>

  private

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recent_hours</span><span class="hljs-params">(<span class="hljs-symbol">prior_to:</span>, <span class="hljs-symbol">history:</span>)</span></span>
    recent_period = frequency.period_before(prior_to.start_at)
    history
      .select { <span class="hljs-params">|reservation|</span> reservation.overlap?(recent_period) }
      .sum(<span class="hljs-number">0</span>) { <span class="hljs-params">|reservation|</span> reservation.duration_in_hours }
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>

ConsecutiveSpreadingRule = Struct.new(<span class="hljs-symbol">:frequency</span>, <span class="hljs-symbol">keyword_init:</span> <span class="hljs-literal">true</span>) <span class="hljs-keyword">do</span>
  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">satisfied?</span><span class="hljs-params">(<span class="hljs-symbol">context:</span>)</span></span>
    history = context.fetch(<span class="hljs-symbol">:history</span>)
    period = context.fetch(<span class="hljs-symbol">:reservation</span>).period
    recent_hours(<span class="hljs-symbol">prior_to:</span> period, <span class="hljs-symbol">history:</span> history).zero?
  <span class="hljs-keyword">end</span>

  private

  <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">recent_hours</span><span class="hljs-params">(<span class="hljs-symbol">prior_to:</span>, <span class="hljs-symbol">history:</span>)</span></span>
    recent_period = frequency.period_before(prior_to.start_at)
    history
      .select { <span class="hljs-params">|reservation|</span> reservation.overlap?(recent_period) }
      .sum(<span class="hljs-number">0</span>) { <span class="hljs-params">|reservation|</span> reservation.duration_in_hours }
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span></pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>We don’t need <code>Location</code> anymore. We introduced it to delegate some work to
them. Those abstraction could be useful but could create a false sense of
abstraction and attract other usages. The more usages there is, the harder it
will be to update it. The definition of one method could sightly differ from
one user to another, forcing us to introduce close and confusing naming or
complex parameters to change the meaning of a method. All that, depending on
the context.</p>

            </div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>In the example, even <code>#covered_hours</code> was taken out of the <code>Period</code> class as
its behavior is a bit too specific to our <code>HourOfDayRule</code>. Same for the
<code>Studio#match?</code> method.</p>

            </div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <p>Sadly we already have a bit of duplication around <code>#recent_hours</code>. Having this
shared between rules wouldn’t be a problem. A mixin could do that, but you
would have to do that explicitly.</p>

            </div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
